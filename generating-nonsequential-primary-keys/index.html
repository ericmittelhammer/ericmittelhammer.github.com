<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Generating Nonsequential Primary Keys</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/normalize.css">
        <link rel="stylesheet" href="/css/main.css">
        <link rel="stylesheet" href="/css/font-awesome.min.css">
        <link href='http://fonts.googleapis.com/css?family=Lato:400italic,700italic,400,700' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="http://softwaremaniacs.org/media/soft/highlight/styles/sunburst.css">
        <link rel="stylesheet" href="/css/site.css">
        <script src="http://softwaremaniacs.org/media/soft/highlight/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script src="/js/vendor/modernizr-2.6.2.min.js"></script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->
        <div id="main">
            <header id="global">
                <a href="/" id="blog-title">Eric Mittelhammer</a>
                <p class="about">Software guy doing software things.</p>
                <ul id="social">
                    <li><script type="text/javascript">
                    document.write("<a href=\"mail" + "to:" + new Array("blog","ericmittelhammer.com").join("@") + "\">" + "<i class=\"icon-envelope-alt\"></i>" + "</" + "a>");
                </script></li>
                <li><a href="http://twitter.com/emittelhammer"><i class="icon-twitter"></i></a></li>
                <li><a href="https://github.com/ericmittelhammer"><i class="icon-github"></i></a></li>
            </ul>
            </header>   
            <div class="content">
            <!-- Add your site or application content here -->
              <div id="post">
  	<div class="post-content">
	    <h1 class="post-title">Generating Nonsequential Primary Keys</h1>
	    <hr/>
	    <p><p>Auto-incremented primary keys are nearly ubiquitous in DBMSs.  But for multi-master or sharded systems, they introduce the possibility (certainty?) of collision.   They are also sequential, and therefore, predictable - which is not always ideal.  Here's a pretty simple way to create nonsequential unique keys accross your entire system.</p>

<!--more-->


<p>To guarantee that keys will be unique, you have to either generate them all in the same place, or rely on the client to supply a unique ID when it creates a new record.  By using a single generation source, you could possibly create a performance bottleneck while introducing a single point of failure.  Instead, we'll generate unique keys on each client. This method requires the use of a much larger range of numbers than you'd normally use for an autoincrement column (you'll see why below).  Keep in mind this will be multiplied in every table in which you use this column as a foreign key.</p>

<p>We're going to compose our key from three components:</p>

<ol>
<li>A timestamp.</li>
<li>A 'generator id' - something that will uniquely identify the node creating the record.</li>
<li>A random number - to provide uniqueness beyond the precision of the timestamp.</li>
</ol>


<p>Let's start with the timestamp.  We'll be using standard UNIX timestamp to a precision level of milliseconds.  That is, the number of milliseconds since the Unix Epoch:  January 1, 1970 00:00:00 UTC.  Using Python, the time() function returns a float reperesenting the number of seconds since the Epoch, so to get the number of milliseconds as an integer:</p>

<pre><code class="python" style="font-size:.9em">>>> int(time.time()*1000)
1347927116156</code></pre>


<p>Of course, YMMV depending on your choice of language...</p>

<p>Now let's take a look at how to store it.  1346472000000 is the number of milliseconds between the Epoch and midnight, September 1st, 2012.</p>

<p>Converted to binary:</p>

<pre><code class="python" style="font-size:.9em">>>> bin(1346472000000)
'0b10011100101111111111111000011101000000000'</code></pre>


<p>That's a 41-bit integer.  The largest number we can store in the same space is 2199023255551, or 2<sup>41</sup>-1.<br/>
See:</p>

<pre><code class="python" style="font-size:.9em">>>> bin(int(math.pow(2, 41))-1)
'0b11111111111111111111111111111111111111111'</code></pre>


<p>That represents September 7th, 2039.  This is just fine for my purposes, but if you like, you can use a 42-bit number which will get you to May 15th 2109.</p>

<p>At this point, we've already exceeded the 32-bit INTEGER size of most databases, so we'll have to use a 64-bit number which will fit into the BIGINT datatype.</p>

<p>In order to compose a single integer from multiple components, we'll bit-shift each one to the left, making room for the next. By shifting the timestamp first it becomes the most significant component of the number, with a few advantages:</p>

<ul>
<li>The timestamp can always be extracted from the key by shifting right.  A creation TIMESTAMP column is likely something you'll have anyway.  It softens the blow of having such a large key if you can eliminate an entire column.</li>
<li>By making the timestamp the most significant part of the number, it guarantees that the rows can be ordered by their creation time.  This will also allow any indexes to be added sequentially, rather than having to insert them in-place.</li>
</ul>


<p>The shift:</p>

<pre><code class="python" style="font-size:.9em">>>> bin(1346472000000 << 23)
'0b1001110010111111111111100001110100000000000000000000000000000000'</code></pre>


<p>That leaves 23 bits for the other components of the number.  We'll do as follows:</p>

<ul>
<li>10 bits for the generator ID.  This gives us 2<sup>10</sup>-1 (or 1023) possible IDs.  That should be plenty.  If you are running a cluster of more than 1023 nodes, I suspect you're not looking to the blogosphere for your key generation scheme.  This is also a good place for a shard ID if you are saving out ot a shrded cluster.</li>
<li>The remaining 13 bits for a random number - That's between 1 and 8191.  Again; if you are generating more than 8000 ids per millisecond, per node, you probably don't need <em>my</em> help.</li>
</ul>


<p>Of course, you could always tweak the number of bits you use for each component to suit your needs.</p>

<p>To review, our components are:</p>

<ul>
<li>A 41-bit timestamp shifted left by 23 bits</li>
<li>A 10-bit (maximum) generator ID shifted left by 13 bits</li>
<li>A 13-bit (maximum) random number.</li>
</ul>


<p>In order to combine these into a single integer, we can simply add them together. Since we specifically shifted bits out of the way of each other, a bitwise AND will yield the same result.</p>

<p>First, lets try it with some easy-to-test values:</p>

<pre><code class="python" style="font-size:.9em">>>> bin((1346472000000 << 23) + (1 << 13) + 1)
'0b1001110010111111111111100001110100000000000000000010000000000001'
>>> bin((1346472000000 << 23) + (int(math.pow(2,9)) << 13) + int(math.pow(2,12)))
'0b1001110010111111111111100001110100000000010000000001000000000000'
>>> bin((1346472000000 << 23) + (int(math.pow(2,10)-1) << 13) + int(math.pow(2,13)-1))
'0b1001110010111111111111100001110100000000011111111111111111111111'</code></pre>


<p>As you can see, the number is correctly segmented at the 23 and 13 bit places.</p>

<p>Combining it all into a single, simple function:</p>

<pre><code class="python" style="font-size:.9em">def nonsequential_key(generator_id):
    now = int(time.time()*1000)
    rdm = random.randint(1, 8191)
    return ((now << 23) + (generator_id << 13) + rdm)</code></pre>


<p>Finally, here it is in action (showing the returned decimal integer values):</p>

<pre><code class="python" style="font-size:.9em">>>> nskey.nonsequential_key(1)
11402993483053546203L
>>> nskey.nonsequential_key(1)
11402993501995022952L
>>> nskey.nonsequential_key(1)
11402993515760721961L</code></pre>



</p>
	</div>
  </div>

            </div>
        </div>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="js/vendor/jquery-1.8.3.min.js"><\/script>')</script>
        <script src="/js/plugins.js"></script>
        <script src="/js/main.js"></script>

        <!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
        <script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-25868864-1']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

        </script>
    </body>
</html>
